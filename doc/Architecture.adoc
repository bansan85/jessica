:last-update-label!:
:source-highlighter: highlight.js
:highlightjsdir: highlight

= Architecture

== Library

=== Export the interface

The whole backend is build in a single library.

The library must be buildable with option `-fvisibility=hidden`. So all symbols that need to be used must be explicitly exported.

For this job, it will be used:

- `\__declspec(dllimport)` and `__declspec(dllexport)` will be used for https://docs.microsoft.com/en-us/cpp/build/importing-and-exporting[Windows],
- `\\__attribute__((visibility("default")))` will be used for Linux.

Internally, you must define the macro `BUILDING_JESSICA_DLL`.

== Manage data

Data are stored in class.

Each of these class have two classes: an adapter and the implementation.
Between adapter and implementation, you may add decorators.

=== History

At first, each adapter inherited from a https://github.com/bansan85/jessica/blob/5860d813a852e68cf2cb9be009fce03d7b39dc39/include/jessica/data/load/vertical_eccentric.h[pure virtual class].

Then adapter needed to be templated to support decorator, I decided to use https://github.com/bansan85/jessica/blob/4e7884bb98f24c3a1146a1ef0119f20ab84023c1/include/jessica/data/load/vertical_eccentric_concept.h[concept] with accessor.

Finally I needed to have a very generic getter and setter to reduce the need of boilerplate to access multiple levels of data. There is only one primary template function `f` for accessor. Specialization when needed is done with `requires` keyword instead of historic template specialization or use of `std::enable_if<>`. I removed concept interface because it can not force specialization of primary template.

GoogleTest supports mocking with template.

=== Adapter

All accessors use the same template function `f`.

You will need two explicit symbol. The first tells if it's a getter or a setter. The second tells which information do you want. This second part may be multiple if you need to go in nested accessor.

If you want to get a value, the first explicit typename is `false`: `f<F::Get, F::Data>()`.

If you want to set a value, the first explicit typename is `true`: `f<F::Set, F::Data, F::Data2>(value)`. The type of the value returned is a `std::shared_ptr<...>` of the current object.

  * Coding style

Copy constructor must be public to use `std::make_shared`.

Ownership of a return value of a setter must be able to be shared. Use a `std::shared_ptr<>`. Pass them by const reference in function and store them by copy in class.

  * Example of declaration

Adapter for a strip foundation. If you do not need decorator, just use `FoundationStripImpl` for `T`;

[source,cpp]
----
#include <jessica/compat.h>
#include <jessica/helper/template.h>

namespace jessica
{
template <typename T>
class JESSICA_DLL_PUBLIC FoundationStrip final
{
 public:
  FoundationStrip() = default;
  FoundationStrip(const FoundationStrip&) = default;
  FoundationStrip(FoundationStrip&&) = delete;
  FoundationStrip& operator=(const FoundationStrip&) = delete;
  FoundationStrip& operator=(FoundationStrip&&) = delete;

  template <F Action, F... U, typename... Args>
  [[nodiscard]] auto f(const Args&&... args) const
  {
    if constexpr (Action == F::Set)
    {
      auto retval = Clone();
      retval->impl_ = T::template f<Action, U...>(
          *impl_, std::forward<const Args>(args)...);
      return retval;
    }
    else
    {
      return T::template f<Action, U...>(*impl_,
                                         std::forward<const Args>(args)...);
    }
  }

  [[nodiscard]] std::shared_ptr<FoundationStrip<T>> Clone() const
  {
    return std::make_shared<FoundationStrip<T>>(*this);
  }

 private:
  std::shared_ptr<FoundationStripImpl> impl_ =
      std::make_shared<FoundationStripImpl>();
};
}  // namespace jessica
----

=== Implementation behind the adapter

Example of class `FoundationStripImpl`.

You need to define specialization of the primary `f` function.

[source,cpp]
----
#include <jessica/compat.h>
#include <jessica/helper/template.h>

namespace jessica
{
class JESSICA_DLL_PUBLIC FoundationStripImpl
{
 public:
  FoundationStripImpl() = default;
  FoundationStripImpl(const FoundationStripImpl&) = default;
  FoundationStripImpl(FoundationStripImpl&&) = delete;
  FoundationStripImpl& operator=(const FoundationStripImpl&) = delete;
  FoundationStripImpl& operator=(FoundationStripImpl&&) = delete;

  template <F T>
  requires Equals<F, T, F::Clone>
  [[nodiscard]] static std::shared_ptr<FoundationStripImpl>
      f(const FoundationStripImpl& self)
  {
    return std::make_shared<FoundationStripImpl>(self);
  }

  template <F Action, F T>
  requires Equals<F, Action, F::Get> && Equals<F, T, F::B>
  [[nodiscard]] static double f(const FoundationStripImpl& self)
  {
    return self.b_;
  }

  template <F Action, F T>
  requires Equals<F, Action, F::Set> && Equals<F, T, F::B>
  [[nodiscard]] static std::shared_ptr<FoundationStripImpl>
      f(const FoundationStripImpl& self, const double b)
  {
    auto retval = f<F::Clone>(self);
    retval->b_ = b;
    return retval;
  }

 private:
  double b_ = std::numeric_limits<double>::quiet_NaN();
};
}  // namespace jessica
----

=== Decorator

Decorators may be add between the adapter and the implementation.

They implement the same `f` functions. If needed, you can specialize some of them.

[source,cpp]
----
template <typename T>
class JESSICA_DLL_PUBLIC LogDuration
{
 public:
  using Type = typename ExtractRootType<T>::type;

  template <F Action, F... U, typename... Args>
  [[nodiscard]] static auto f(const Type& classe, const Args&&... args)
  {
    const auto t_start = std::chrono::high_resolution_clock::now();
    const auto retval =
        T::template f<Action, U...>(classe, std::forward<const Args>(args)...);
    const auto t_end = std::chrono::high_resolution_clock::now();
    const double elapsed_time_ms =
        std::chrono::duration<double, std::milli>(t_end - t_start).count();
    std::cout << "duration " << elapsed_time_ms << " ms" << std::endl;
    return retval;
  }
};
----

=== All together

You can create the data without decorator.

[source,cpp]
----
  const auto load =
      std::make_shared<VerticalEccentric<VerticalEccentricImpl>>();
----

or with decorator.

[source,cpp]
----
  using Decorator = LogCall<LogDuration<VerticalEccentricImpl>>;

  const auto load = std::make_shared<VerticalEccentric<Decorator>>();
----

After, use the instance like that:

[source,cpp]
----
  // Getter
  load->f<F::Get, F::E>();
  // Setter
  const auto load2 = load1->f<F::Set, F::E>(0.2);
----

=== Data inside data

Some class will need to store data from other class.
In this case, you need to specific coding to allow decorator around the main class and if needed decorator around children class.

  * Adapter

The adapter still have one template but the template will have inside the type of the data stored.

An example with only decorator to the main class:

[source,cpp]
----
  // Data 1 without decorator
  using DecoratorFoundation = FoundationStripImpl;
  // Data 2 without decorator
  using DecoratorLoad = VerticalEccentricImpl;
  // Main data with 2 data stored inside.
  using DecoratorCalc = LogCall<LogDuration<
      MeyerhofShallowFoundationImpl<DecoratorLoad, DecoratorFoundation>>>;

  MeyerhofShallowFoundation<DecoratorCalc> calculator(...);
----

And the same with a decorator for every data:

[source,cpp]
----
  // Data 1 with decorator
  using DecoratorFoundation = LogCall<LogDuration<FoundationStripImpl>>;
  // Data 2 with decorator
  using DecoratorLoad = LogCall<LogDuration<VerticalEccentricImpl>>;
  // Main data with 2 data stored inside.
  using DecoratorCalc = LogCall<LogDuration<
      MeyerhofShallowFoundationImpl<DecoratorLoad, DecoratorFoundation>>>;

  MeyerhofShallowFoundation<DecoratorCalc> calculator(...);
----

For example, Meyerhof have two data stored.

There is two `using`: `T0` and `T1`. They extract types from the main template.
The goal is to reduce the length when declaring the template.

Because this class has two data stored, you need to add boilerplates to all accessors from the main class. They are added in adapter with the generic templated `f` function.

[source,cpp]
----
template <typename T>
class JESSICA_DLL_PUBLIC MeyerhofShallowFoundation final
{
 public:
  using T0 = typename ExtractRootTypeN<0, T>::type;
  using T1 = typename ExtractRootTypeN<1, T>::type;

  MeyerhofShallowFoundation()
      : impl_(std::make_shared<MeyerhofShallowFoundationImpl<T0, T1>>(
            std::make_shared<VerticalEccentric<T0>>(),
            std::make_shared<FoundationStrip<T1>>()))
  {
  }
  MeyerhofShallowFoundation(
      const std::shared_ptr<VerticalEccentric<T0>>& load,
      const std::shared_ptr<FoundationStrip<T1>>& foundation)
      : impl_(std::make_shared<MeyerhofShallowFoundationImpl<T0, T1>>(
            load, foundation))
  {
  }
  MeyerhofShallowFoundation(const MeyerhofShallowFoundation&) = default;
  MeyerhofShallowFoundation(MeyerhofShallowFoundation&&) = delete;
  MeyerhofShallowFoundation&
      operator=(const MeyerhofShallowFoundation&) = delete;
  MeyerhofShallowFoundation& operator=(MeyerhofShallowFoundation&&) = delete;
  ~MeyerhofShallowFoundation() = default;

  template <F Action, F... U, typename... Args>
  [[nodiscard]] auto f(const Args&&... args) const
  {
    if constexpr (Action == F::Set)
    {
      auto retval = Clone();
      retval->impl_ = T::template f<Action, U...>(
          *impl_, std::forward<const Args>(args)...);
      return retval;
    }
    else
    {
      return T::template f<Action, U...>(*impl_,
                                         std::forward<const Args>(args)...);
    }
  }

  [[nodiscard]] std::shared_ptr<MeyerhofShallowFoundation> Clone() const
  {
    return std::make_shared<MeyerhofShallowFoundation>(*this);
  }

 private:
  std::shared_ptr<MeyerhofShallowFoundationImpl<T0, T1>> impl_;
};
----

  * Implementation

The implementation needs to have as template the type of data store (`T0` and `T1`).

[source,cpp]
----
template <typename T0, typename T1>
class JESSICA_DLL_PUBLIC MeyerhofShallowFoundationImpl
{
 public:
  MeyerhofShallowFoundationImpl(
      const std::shared_ptr<VerticalEccentric<T0>>& load,
      const std::shared_ptr<FoundationStrip<T1>>& foundation)
      : load_(load), foundation_(foundation)
  {
  }
  MeyerhofShallowFoundationImpl(const MeyerhofShallowFoundationImpl&) = default;
  MeyerhofShallowFoundationImpl(MeyerhofShallowFoundationImpl&&) = delete;
  MeyerhofShallowFoundationImpl&
      operator=(const MeyerhofShallowFoundationImpl&) = delete;
  MeyerhofShallowFoundationImpl&
      operator=(MeyerhofShallowFoundationImpl&&) = delete;

  template <F T>
  requires Equals<F, T, F::Clone>
  [[nodiscard]] static std::shared_ptr<MeyerhofShallowFoundationImpl>
      f(const MeyerhofShallowFoundationImpl& self)
  {
    return std::make_shared<MeyerhofShallowFoundationImpl>(self);
  }

  template <F Action, F T>
  requires Equals<F, Action, F::Get> && Equals<F, T, F::B_>
  [[nodiscard]] static double f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.foundation_->template f<F::Get, F::B>() -
           2. * self.load_->template f<F::Get, F::E>();
  }

  template <F Action, F T>
  requires Equals<F, Action, F::Get> && Equals<F, T, F::Qref>
  [[nodiscard]] static double f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.load_->template f<F::Get, F::V>() / f<F::Get, F::B_>(self);
  }

  template <F Action, F T, F... U, typename... Args>
  requires Equals<F, Action, F::Get> && Equals<F, T, F::Load>
  [[nodiscard]] static double f(const MeyerhofShallowFoundationImpl& self,
                                const Args&&... args)
  {
    return self.load_->template f<Action, U...>(
        std::forward<const Args>(args)...);
  }

  template <F Action, F T, F... U, typename... Args>
  requires Equals<F, Action, F::Set> && Equals<F, T, F::Load>
  [[nodiscard]] static std::shared_ptr<MeyerhofShallowFoundationImpl>
      f(const MeyerhofShallowFoundationImpl& self, const Args&&... args)
  {
    auto retval = f<F::Clone>(self);
    retval->load_ = retval->load_->template f<Action, U...>(
        std::forward<const Args>(args)...);
    return retval;
  }

  template <F Action, F T, F... U, typename... Args>
  requires Equals<F, Action, F::Get> && Equals<F, T, F::Foundation>
  [[nodiscard]] static double f(const MeyerhofShallowFoundationImpl& self,
                                const Args&&... args)
  {
    return self.foundation_->template f<Action, U...>(
        std::forward<const Args>(args)...);
  }

  template <F Action, F T, F... U, typename... Args>
  requires Equals<F, Action, F::Set> && Equals<F, T, F::Foundation>
  [[nodiscard]] static std::shared_ptr<MeyerhofShallowFoundationImpl>
      f(const MeyerhofShallowFoundationImpl& self, const Args&&... args)
  {
    auto retval = f<F::Clone>(self);
    retval->foundation_ = retval->foundation_->template f<Action, U...>(
        std::forward<const Args>(args)...);
    return retval;
  }

 private:
  std::shared_ptr<VerticalEccentric<T0>> load_;
  std::shared_ptr<FoundationStrip<T1>> foundation_;
};
----
