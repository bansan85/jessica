:last-update-label!:
:source-highlighter: highlight.js
:highlightjsdir: highlight

= Architecture

== Library

=== Export the interface

The whole backend is build in a single library.

The library must be buildable with option `-fvisibility=hidden`. So all symbols that need to be used must be explicitly exported.

For this job, it will be used:

- `\__declspec(dllimport)` and `__declspec(dllexport)` will be used for https://docs.microsoft.com/en-us/cpp/build/importing-and-exporting[Windows],
- `\\__attribute__((visibility("default")))` will be used for Linux.

Internally, you must define the macro `BUILDING_JESSICA_DLL`.

== Manage data

Data are stored in class.

Each of these class have an interface with concept.

The implementation of the interface is just an adapter to the class that really store the data.

Between each adapter and data, you may add decorators.

=== Interface

Each public class should have an interface. This ease test (perfectly compatible with mock of gtest) and hide implementation and private fields.

Ownership of a return value of a setter must be able to be shared. Use a `std::shared_ptr<>`. Pass them by reference and store them by copy.

Exemple of interface:

[source,cpp]
----
#if !defined(JCONCEPTS) && __has_include(<concepts>)
  #define JCONCEPTS
  #include <concepts>
#endif

#ifdef JCONCEPTS
  #include <memory>

namespace Jessica::Data::Geotechnical
{
template <typename T>
concept FoundationStripConcept = requires(const T t)
{
  {
    t.Clone()
  }
  ->std::same_as<std::shared_ptr<T>>;
  {
    t.B()
  }
  ->std::same_as<double>;
  {
    t.B(std::declval<double>())
  }
  ->std::same_as<std::shared_ptr<T>>;
};
}  // namespace Jessica::Data::Geotechnical

#endif
----

TODO: remove `JCONCEPTS` when emscripten will support concepts.

=== Adapter behind the interface

The interface use a standard paradigm of programmation.
But internally, all functions are redirected to functions that all overload the same function `f`.
The goal is to ease the use of template class to decorate all functions with a single template function.

To deal with functions without argument or with same number of arguments of same type, I needed to add an explicit symbol.
I don't want to force this symbol (a `struct`) in argument to avoid empty parameter. So I also add this symbol in the name via `template`. This symbol will be explicit for function without argument and implicit for function with arguments:

[source,cpp]
----
T::template f<FoundationStripImpl::GetB>(*impl_);
T::template f(*retval->impl_, FoundationStripImpl::SetB{.b = b});
----

Copy constructor must be public to use `std::make_shared`.

Example of class that convert a class with classic functions `FoundationStrip` to a class with all the same functions `f` `FoundationStripImpl`.

You can noticed the class is template. This is to add decorator to the class (see after). If decorator is not needed, just use `FoundationStripImpl` as template;

[source,cpp]
----
#include <jessica/compat.h>
#include <jessica/data/geotechnical/foundation_strip_concept.h>
#include <jessica/helper/template.h>

namespace Jessica::Data::Geotechnical
{
template <typename T>
class JESSICA_DLL_PUBLIC FoundationStrip final
{
 public:
  FoundationStrip() = default;
  FoundationStrip(const FoundationStrip&) = default;
  FoundationStrip(FoundationStrip&&) = delete;
  FoundationStrip& operator=(const FoundationStrip&) = delete;
  FoundationStrip& operator=(FoundationStrip&&) = delete;

  [[nodiscard]] std::shared_ptr<FoundationStrip<T>> Clone() const
  {
    return std::make_shared<FoundationStrip<T>>(*this);
  }

  [[nodiscard]] double B() const
  {
    return T::template f<FoundationStripImpl::GetB>(*impl_);
  }

  [[nodiscard]] std::shared_ptr<FoundationStrip<T>> B(double b) const
  {
    auto retval = std::make_shared<FoundationStrip<T>>(*this);
    retval->impl_ =
        T::template f(*retval->impl_, FoundationStripImpl::SetB{.b = b});
    return retval;
  }

 private:
  std::shared_ptr<FoundationStripImpl> impl_ =
      std::make_shared<FoundationStripImpl>();
};

#ifdef JCONCEPTS
static_assert(FoundationStripConcept<FoundationStrip<int>>);
#endif
}  // namespace Jessica::Data::Geotechnical
----

=== Implementation behind the adapter

Example of class `..Impl`:

Inside the class, you must start to define the symbol that will be used to specialize `f` function.
This struct must define an explicit `ReturnType`.

In this example, standard specialization is used.

[source,cpp]
----
#include <jessica/compat.h>
#include <jessica/helper/template.h>

namespace Jessica::Data::Geotechnical
{
class JESSICA_DLL_PUBLIC FoundationStripImpl
{
 public:
  struct Clone
  {
    using ReturnType = std::shared_ptr<FoundationStripImpl>;
  };

  struct GetB
  {
    using ReturnType = double;
  };

  struct SetB
  {
    using ReturnType = std::shared_ptr<FoundationStripImpl>;
    double b;
  };

  FoundationStripImpl() = default;
  FoundationStripImpl(const FoundationStripImpl&) = default;
  FoundationStripImpl(FoundationStripImpl&&) = delete;
  FoundationStripImpl& operator=(const FoundationStripImpl&) = delete;
  FoundationStripImpl& operator=(FoundationStripImpl&&) = delete;

  template <typename T>
  static typename T::ReturnType f(const FoundationStripImpl&)
  {
    static_assert(Jessica::Helper::StaticAssert<T>::value, "Must specialized");
  }

  template <typename T>
  static typename T::ReturnType f(const FoundationStripImpl&, const T&)
  {
    static_assert(Jessica::Helper::StaticAssert<T>::value, "Must specialized");
  }

 private:
  double b_ = std::numeric_limits<double>::quiet_NaN();
};

template <>
[[nodiscard]] std::shared_ptr<FoundationStripImpl>
FoundationStripImpl::f<FoundationStripImpl::Clone>(
    const FoundationStripImpl& self)
{
  return std::make_shared<FoundationStripImpl>(self);
}

template <>
[[nodiscard]] double FoundationStripImpl::f<FoundationStripImpl::GetB>(
    const FoundationStripImpl& self)
{
  return self.b_;
}

template <>
[[nodiscard]] std::shared_ptr<FoundationStripImpl> FoundationStripImpl::f<>(
    const FoundationStripImpl& self, const SetB& b)
{
  auto retval = f<FoundationStripImpl::Clone>(self);
  retval->b_ = b.b;
  return retval;
}
}  // namespace Jessica::Data::Geotechnical
----

=== Decorator

Decorators may be add between the adapter and the implementation.

You have to implement two generalized template functions.
One for `f` functions without argument and one for `f` functions with arguments.

If needed, you can specialize some functions.

[source,cpp]
----
template <typename T>
class JESSICA_DLL_PUBLIC LogCall
{
 public:
  using Root = typename Jessica::Helper::ExtractRootType<T>::Root;

  template <typename Args>
  static auto f(const Root& classe, const Args&& args)
  {
    std::cout << "DecoratorLogger " << typeid(T).name() << " "
              << typeid(Args).name() << std::endl;
    return T::template f(classe, std::forward<const Args>(args));
  }

  template <typename Args>
  static auto f(const Root& classe)
  {
    std::cout << "DecoratorLogger " << typeid(T).name() << " "
              << typeid(Args).name() << std::endl;
    return T::template f<Args>(classe);
  }
};
----

=== All together

You can create the data without decorator.

[source,cpp]
----
  const auto load = std::make_shared<Jessica::Data::Load::VerticalEccentric<
      Jessica::Data::Load::VerticalEccentricImpl>>();
----

or with decorator.

[source,cpp]
----
  using Decorator =
      Jessica::Util::Decorator::LogCall<Jessica::Util::Decorator::LogDuration<
          Jessica::Data::Load::VerticalEccentricImpl>>;

  const auto load =
      std::make_shared<Jessica::Data::Load::VerticalEccentric<Decorator>>();
----

After, use the instance just the standard way.

[source,cpp]
----
  const auto load2 = load->V(100000.);
----

=== Data inside data

Some class will need to store data from other class.
In this case, you need to specific coding to allow decorator around the main class and if needed decorator around children class.

  * Interface

The interface follows the same principle than previously described.

  * Adapter

The adapter still have one template but the template will have inside the type of the data stored. For example:

[source,cpp]
----
  // Data 1 without decorator
  using DecoratorFoundation = Jessica::Data::Geotechnical::FoundationStripImpl;
  // Data 2 without decorator
  using DecoratorLoad = Jessica::Data::Load::VerticalEccentricImpl;
  // Main data with 2 data stored inside.
  using DecoratorCalc =
      Jessica::Util::Decorator::LogCall<Jessica::Util::Decorator::LogDuration<
          Jessica::Calc::Geotechnical::MeyerhofShallowFoundationImpl<
              DecoratorLoad, DecoratorFoundation>>>;

  MeyerhofShallowFoundation<DecoratorCalc> calculator(...);
----

And the same with a decorator for every data:

[source,cpp]
----
  // Data 1 with decorator
  using DecoratorFoundation =
      Jessica::Util::Decorator::LogCall<Jessica::Util::Decorator::LogDuration<
          Jessica::Data::Geotechnical::FoundationStripImpl>>;
  // Data 2 with decorator
  using DecoratorLoad =
      Jessica::Util::Decorator::LogCall<Jessica::Util::Decorator::LogDuration<
          Jessica::Data::Load::VerticalEccentricImpl>>;
  // Main data with 2 data stored inside.
  using DecoratorCalc =
      Jessica::Util::Decorator::LogCall<Jessica::Util::Decorator::LogDuration<
          Jessica::Calc::Geotechnical::MeyerhofShallowFoundationImpl<
              DecoratorLoad, DecoratorFoundation>>>;

  MeyerhofShallowFoundation<DecoratorCalc> calculator(...);
----

For example, Meyerhof have two data stored.

There is two `using`: `U` and `W`. They extract type from the main template.
The goal is to reduce the length when declaring the template.

Because this class has two data stored, you need to backport all accessors to the main class.

[source,cpp]
----
template <typename T>
class JESSICA_DLL_PUBLIC MeyerhofShallowFoundation final
{
 public:
  using U = typename Jessica::Helper::ExtractRootTypeN<0, T>::Root;
  using V = typename Jessica::Helper::ExtractRootTypeN<1, T>::Root;

  MeyerhofShallowFoundation()
      : impl_(std::make_shared<MeyerhofShallowFoundationImpl<U, V>>(
            std::make_shared<Jessica::Data::Load::VerticalEccentric<U>>(),
            std::make_shared<
                Jessica::Data::Geotechnical::FoundationStrip<V>>()))
  {
  }
  MeyerhofShallowFoundation(
      const std::shared_ptr<Jessica::Data::Load::VerticalEccentric<U>>& load,
      const std::shared_ptr<Jessica::Data::Geotechnical::FoundationStrip<V>>&
          foundation)
      : impl_(std::make_shared<MeyerhofShallowFoundationImpl<U, V>>(load,
                                                                    foundation))
  {
  }
  MeyerhofShallowFoundation(const MeyerhofShallowFoundation&) = default;
  MeyerhofShallowFoundation(MeyerhofShallowFoundation&&) = delete;
  MeyerhofShallowFoundation& operator=(const MeyerhofShallowFoundation&) =
      delete;
  MeyerhofShallowFoundation& operator=(MeyerhofShallowFoundation&&) = delete;
  ~MeyerhofShallowFoundation() = default;

  [[nodiscard]] std::shared_ptr<MeyerhofShallowFoundation> Clone() const
  {
    return std::make_shared<MeyerhofShallowFoundation>(*this);
  }

  [[nodiscard]] double Qref() const
  {
    return T::template f<typename MeyerhofShallowFoundationImpl<U, V>::GetQref>(
        *impl_);
  }

  [[nodiscard]] double B_() const
  {
    return T::template f<typename MeyerhofShallowFoundationImpl<U, V>::GetB_>(
        *impl_);
  }

  [[nodiscard]] double LoadV() const
  {
    return T::template f<
        typename MeyerhofShallowFoundationImpl<U, V>::GetLoadV>(*impl_);
  }

  [[nodiscard]] std::shared_ptr<MeyerhofShallowFoundation> LoadV(double v) const
  {
    auto retval = Clone();
    retval->impl_ = T::template f(
        *retval->impl_,
        typename MeyerhofShallowFoundationImpl<U, V>::SetLoadV{.v = v});
    return retval;
  }

  [[nodiscard]] double LoadE() const
  {
    return T::template f<
        typename MeyerhofShallowFoundationImpl<U, V>::GetLoadE>(*impl_);
  }

  [[nodiscard]] std::shared_ptr<MeyerhofShallowFoundation> LoadE(double e) const
  {
    auto retval = Clone();
    retval->impl_ = T::template f(
        *retval->impl_,
        typename MeyerhofShallowFoundationImpl<U, V>::SetLoadE{.e = e});
    return retval;
  }

  [[nodiscard]] double FoundationB() const
  {
    return T::template f<
        typename MeyerhofShallowFoundationImpl<U, V>::GetFoundationB>(*impl_);
  }

  [[nodiscard]] std::shared_ptr<MeyerhofShallowFoundation> FoundationB(
      double b) const
  {
    auto retval = Clone();
    retval->impl_ = T::template f(
        *retval->impl_,
        typename MeyerhofShallowFoundationImpl<U, V>::SetFoundationB{.b = b});
    return retval;
  }

 private:
  std::shared_ptr<MeyerhofShallowFoundationImpl<U, V>> impl_;
};

----

  * Implementation

The implementation needs to have as template the type of data store (`U` and `V`).

This will create a problem for the specialization of `f` functions. They must be specialized with `T` and without `U` and `V`.

Standard says that only class may be partial specialized. Function must be fully specialized. Plus, to be able to specialized a function, the class must be specialized.

Usage of `std::enable_if` will allow to specialized function with class non specialized.

[source,cpp]
----
template <typename U, typename V>
class JESSICA_DLL_PUBLIC MeyerhofShallowFoundationImpl
{
 public:
  struct Clone
  {
    using ReturnType = std::shared_ptr<MeyerhofShallowFoundationImpl>;
  };

  struct GetQref
  {
    using ReturnType = double;
  };

  struct GetB_
  {
    using ReturnType = double;
  };

  struct GetLoadV
  {
    using ReturnType = double;
  };

  struct SetLoadV
  {
    using ReturnType = std::shared_ptr<MeyerhofShallowFoundationImpl>;
    double v;
  };

  struct GetLoadE
  {
    using ReturnType = double;
  };

  struct SetLoadE
  {
    using ReturnType = std::shared_ptr<MeyerhofShallowFoundationImpl>;
    double e;
  };

  struct GetFoundationB
  {
    using ReturnType = double;
  };

  struct SetFoundationB
  {
    using ReturnType = std::shared_ptr<MeyerhofShallowFoundationImpl>;
    double b;
  };

  MeyerhofShallowFoundationImpl(
      const std::shared_ptr<Data::Load::VerticalEccentric<U>>& load,
      const std::shared_ptr<Data::Geotechnical::FoundationStrip<V>>& foundation)
      : load_(load), foundation_(foundation)
  {
  }
  MeyerhofShallowFoundationImpl(const MeyerhofShallowFoundationImpl&) = default;
  MeyerhofShallowFoundationImpl(MeyerhofShallowFoundationImpl&&) = delete;
  MeyerhofShallowFoundationImpl& operator=(
      const MeyerhofShallowFoundationImpl&) = delete;
  MeyerhofShallowFoundationImpl& operator=(MeyerhofShallowFoundationImpl&&) =
      delete;

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<Clone, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return std::make_shared<MeyerhofShallowFoundationImpl>(self);
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<GetB_, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.foundation_->B() - 2. * self.load_->E();
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<GetQref, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.load_->V() / f<GetB_>(self);
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<GetLoadV, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.load_->V();
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<SetLoadV, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self, const T& a)
  {
    auto retval = f<Clone>(self);
    retval->load_ = retval->load_->V(a.v);
    return retval;
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<GetLoadE, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.load_->E();
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<SetLoadE, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self, const T& a)
  {
    auto retval = f<Clone>(self);
    retval->load_ = retval->load_->E(a.e);
    return retval;
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<GetFoundationB, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self)
  {
    return self.foundation_->B();
  }

  template <typename T>
  [[nodiscard]] static std::enable_if_t<std::is_same_v<SetFoundationB, T>,
                                        typename T::ReturnType>
  f(const MeyerhofShallowFoundationImpl& self, const T& a)
  {
    auto retval = f<Clone>(self);
    retval->foundation_ = retval->foundation_->B(a.b);
    return retval;
  }

 private:
  std::shared_ptr<Jessica::Data::Load::VerticalEccentric<U>> load_;
  std::shared_ptr<Jessica::Data::Geotechnical::FoundationStrip<V>> foundation_;
};
----
